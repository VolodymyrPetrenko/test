import socket
import threading
import time

# A set to store the IP addresses of clients that have made a request.
seen_clients = set()

def handle_client(client_socket, client_address):
    """
    Handles a single client connection.
    """
    client_ip = client_address[0]

    if client_ip not in seen_clients:
        # First request from this client, simulate a timeout.
        print(f"First request from {client_ip}. Simulating timeout.")
        seen_clients.add(client_ip)
        time.sleep(10)  # Wait for 10 seconds to cause a client-side timeout.
        client_socket.close()
        return

    # Subsequent request from this client.
    print(f"Subsequent request from {client_ip}. Proceeding normally.")

    # Get the request from the client
    request = client_socket.recv(1024)
    if not request:
        client_socket.close()
        return

    # Parse the request to get the destination host and port for CONNECT method
    try:
        first_line = request.decode('utf-8').split('\n')[0]
        method, url, _ = first_line.split()
    except Exception as e:
        print(f"Error parsing request: {e}")
        client_socket.close()
        return


    if method == 'CONNECT':
        try:
            dest_host, dest_port_str = url.split(':')
            dest_port = int(dest_port_str)
        except ValueError:
            # If the port is not specified, default to 443 for HTTPS
            dest_host = url
            dest_port = 443


        try:
            # Create a socket to connect to the destination server
            server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            server_socket.connect((dest_host, dest_port))

            # Send a "200 Connection established" response to the client
            client_socket.sendall(b"HTTP/1.1 200 Connection established\r\n\r\n")

            # Start tunneling data between the client and the server
            def forward(source, destination):
                while True:
                    try:
                        data = source.recv(4096)
                        if data:
                            destination.sendall(data)
                        else:
                            break
                    except Exception:
                        break
                source.close()
                destination.close()

            # Start forwarding in both directions
            threading.Thread(target=forward, args=(client_socket, server_socket)).start()
            threading.Thread(target=forward, args=(server_socket, client_socket)).start()

        except Exception as e:
            print(f"Error connecting to destination: {e}")
            client_socket.close()
    else:
        # Handle non-CONNECT requests if necessary (not implemented in this example)
        print(f"Received non-CONNECT method: {method}. Closing connection.")
        client_socket.close()


def main():
    """
    Main function to start the proxy server.
    """
    host = '127.0.0.1'
    port = 8888

    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server.bind((host, port))
    server.listen(5)

    print(f"[*] Listening on {host}:{port}")

    while True:
        client_socket, addr = server.accept()
        print(f"[*] Accepted connection from: {addr[0]}:{addr[1]}")
        client_handler = threading.Thread(target=handle_client, args=(client_socket, addr))
        client_handler.start()

if __name__ == '__main__':
    main()
