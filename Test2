import socket
import threading
import time
import argparse

# A set to store the IP addresses of clients that have made a request.
seen_clients = set()

def handle_client(client_socket, client_address, delay):
    """
    Handles a single client connection.
    """
    client_ip = client_address[0]

    if client_ip not in seen_clients:
        print(f"First request from {client_ip}. Simulating timeout for {delay} seconds.")
        seen_clients.add(client_ip)
        time.sleep(delay)
        client_socket.close()
        return

    print(f"Subsequent request from {client_ip}. Proceeding normally.")

    try:
        # Receive the initial data packet as raw bytes.
        request_data = client_socket.recv(1024)
        if not request_data:
            client_socket.close()
            return

        # ======================= THE CRITICAL FIX IS HERE =======================
        #
        # 1. Split the raw bytes by the newline character (b'\r\n').
        # 2. Take only the first element ([0]), which is the first line.
        # 3. NOW it is safe to decode that single line as UTF-8.
        #
        first_line = request_data.split(b'\r\n')[0].decode('utf-8')
        # ======================================================================

        method, url, _ = first_line.split()

    except Exception as e:
        # This is the error you are seeing. It happens if the above fix is not applied.
        print(f"Error parsing initial request line: {e}")
        client_socket.close()
        return

    if method == 'CONNECT':
        try:
            # Extract destination host and port from the URL
            if ':' in url:
                dest_host, dest_port_str = url.split(':')
                dest_port = int(dest_port_str)
            else:
                dest_host = url
                dest_port = 443 # Default HTTPS port

            # Connect to the actual destination server
            server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            server_socket.connect((dest_host, dest_port))

            # Inform the client that the tunnel is ready
            client_socket.sendall(b"HTTP/1.1 200 Connection established\r\n\r\n")

            # Start relaying data in both directions (client <--> server)
            def forward(source, destination):
                while True:
                    try:
                        data = source.recv(4096)
                        if data:
                            destination.sendall(data)
                        else:
                            break
                    except OSError: # Handles socket closure
                        break
                source.close()
                destination.close()

            threading.Thread(target=forward, args=(client_socket, server_socket)).start()
            threading.Thread(target=forward, args=(server_socket, client_socket)).start()

        except Exception as e:
            print(f"Error connecting to destination {dest_host}:{dest_port}: {e}")
            client_socket.close()
    else:
        print(f"Received non-CONNECT method: {method}. Closing connection.")
        client_socket.close()

def main():
    """
    Main function to parse arguments and start the proxy server.
    """
    parser = argparse.ArgumentParser(description="Proxy server that times out on the first request.")
    parser.add_argument('--delay', type=int, default=10, help='The delay in seconds for the initial timeout. Default is 10.')
    args = parser.parse_args()
    
    delay_seconds = args.delay
    host = '127.0.0.1'
    port = 8888

    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server.bind((host, port))
    server.listen(5)

    print(f"[*] Listening on {host}:{port}")
    print(f"[*] Initial request timeout is set to {delay_seconds} seconds.")

    while True:
        client_socket, addr = server.accept()
        print(f"[*] Accepted connection from: {addr[0]}:{addr[1]}")
        client_handler = threading.Thread(target=handle_client, args=(client_socket, addr, delay_seconds))
        client_handler.start()

if __name__ == '__main__':
    main()
