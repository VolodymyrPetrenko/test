import socket
import threading
import time
import argparse

# A set to store the IP addresses of clients that have made a request.
seen_clients = set()

def read_http_header(sock):
    """
    Reads from a socket until a complete HTTP header (\r\n\r\n) is received.
    Returns the header as bytes, leaving the rest of the stream untouched.
    """
    header = b''
    while True:
        # Look for the end-of-header sequence
        if b'\r\n\r\n' in header:
            # Separate the header from any potential body/binary data that was read
            header_part, _, rest = header.partition(b'\r\n\r\n')
            # This is complex and not needed for a CONNECT request, but is good practice.
            # For this proxy, we can simplify as the CONNECT request has no body.
            break
        
        # Read a small chunk from the socket
        chunk = sock.recv(64)
        if not chunk:
            # Client disconnected before sending a full header
            return None
        header += chunk
    
    # Return just the first line for our CONNECT request parsing
    return header.split(b'\r\n')[0]


def handle_client(client_socket, client_address, delay):
    """
    Handles a single client connection with a robust header parsing method.
    """
    client_ip = client_address[0]

    if client_ip not in seen_clients:
        print(f"First request from {client_ip}. Simulating timeout for {delay} seconds.")
        seen_clients.add(client_ip)
        time.sleep(delay)
        client_socket.close()
        return

    print(f"Subsequent request from {client_ip}. Proceeding normally.")

    try:
        # ======================= THE ROBUST FIX =======================
        # Use our new function to reliably read only the first line of the header.
        first_line_bytes = read_http_header(client_socket)
        # =============================================================
        
        if not first_line_bytes:
            print("Client disconnected before sending data.")
            client_socket.close()
            return
            
        # Add detailed logging for debugging
        print(f"[*] Received raw header line: {first_line_bytes}")

        # Now it is completely safe to decode this isolated line.
        first_line_str = first_line_bytes.decode('utf-8')
        method, url, _ = first_line_str.split()

    except Exception as e:
        print(f"CRITICAL ERROR during request parsing: {e}")
        client_socket.close()
        return

    if method == 'CONNECT':
        try:
            dest_host, dest_port_str = url.split(':')
            dest_port = int(dest_port_str)
        except ValueError:
            dest_host = url
            dest_port = 443 # Default HTTPS port

        print(f"[*] Tunneling request for {dest_host}:{dest_port}")

        try:
            server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            server_socket.connect((dest_host, dest_port))
            client_socket.sendall(b"HTTP/1.1 200 Connection established\r\n\r\n")

            def forward(source, destination, direction):
                while True:
                    try:
                        data = source.recv(4096)
                        if data:
                            destination.sendall(data)
                        else:
                            break
                    except OSError:
                        break
                print(f"[*] Tunnel {direction} closed.")
                source.close()
                destination.close()

            threading.Thread(target=forward, args=(client_socket, server_socket, f"{client_ip} -> Server")).start()
            threading.Thread(target=forward, args=(server_socket, client_socket, f"Server -> {client_ip}")).start()

        except Exception as e:
            print(f"Error connecting to destination {dest_host}:{dest_port}: {e}")
            client_socket.close()
    else:
        print(f"Received non-CONNECT method: {method}. Closing connection.")
        client_socket.close()

def main():
    parser = argparse.ArgumentParser(description="A robust proxy server that times out on the first request from a client.")
    parser.add_argument('--delay', type=int, default=10, help='The delay in seconds for the initial timeout. Default is 10.')
    args = parser.parse_args()
    
    delay_seconds = args.delay
    host = '127.0.0.1'
    port = 8888

    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server.bind((host, port))
    server.listen(5)

    print(f"[*] Robust proxy listening on {host}:{port}")
    print(f"[*] Initial request timeout is set to {delay_seconds} seconds.")

    while True:
        client_socket, addr = server.accept()
        print(f"[*] Accepted connection from: {addr[0]}:{addr[1]}")
        client_handler = threading.Thread(target=handle_client, args=(client_socket, addr, delay_seconds))
        client_handler.start()

if __name__ == '__main__':
    main()
